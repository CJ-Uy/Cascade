"use client";

import React, { useState, useEffect, useTransition } from "react";
import { Button } from "@/components/ui/button";
import { toast } from "sonner";
import { updateTemplateFields } from "../actions";
import {
  FormBuilder as ExistingFormBuilder,
  FormField,
  FieldType,
} from "@/app/(main)/management/forms/[bu_id]/(components)/FormBuilder";

interface FormBuilderWrapperProps {
  initialTemplate: {
    id: string;
    name: string;
    description: string | null;
    fields: {
      id: string;
      label: string;
      field_type: string;
      is_required: boolean;
      placeholder: string | null;
      order: number;
      options: { label: string; value: string }[];
      parent_list_field_id: string | null;
    }[];
  };
}

// Map database field_type to FormBuilder's FieldType
const mapDbFieldTypeToFormBuilderFieldType = (dbType: string): FieldType => {
  switch (dbType) {
    case "text":
      return "short-text";
    case "textarea":
      return "long-text";
    case "number":
      return "number";
    case "select":
      return "radio"; // Assuming select maps to radio for simplicity in this builder
    case "checkbox":
      return "checkbox";
    case "table":
      return "table";
    case "file-upload":
      return "file-upload";
    default:
      return "short-text"; // Default to short-text or handle error
  }
};

// Map FormBuilder's FieldType to database field_type
const mapFormBuilderFieldTypeToDbFieldType = (fbType: FieldType): string => {
  switch (fbType) {
    case "short-text":
      return "text";
    case "long-text":
      return "textarea";
    case "number":
      return "number";
    case "radio":
      return "select"; // Assuming radio maps to select in db
    case "checkbox":
      return "checkbox";
    case "table":
      return "table";
    case "file-upload":
      return "file-upload";
    default:
      return "text"; // Default to text
  }
};

// Recursive mapping from DB field structure to FormBuilder's FormField structure
const mapDbFieldToFormBuilderField = (
  dbField: any,
  allDbFields: any[],
): FormField => {
  const formField: FormField = {
    id: dbField.id,
    type: mapDbFieldTypeToFormBuilderFieldType(dbField.field_type),
    label: dbField.label,
    required: dbField.is_required,
    placeholder: dbField.placeholder || undefined,
  };

  if (dbField.options && dbField.options.length > 0) {
    formField.options = dbField.options.map((opt: any) => opt.value);
  }

  if (dbField.field_type === "table") {
    formField.columns = allDbFields
      .filter((f) => f.parent_list_field_id === dbField.id)
      .sort((a, b) => a.order - b.order)
      .map((col) => mapDbFieldToFormBuilderField(col, allDbFields)); // Recursive call for nested columns
  }

  return formField;
};

// Recursive mapping from FormBuilder's FormField structure to DB field structure
const mapFormBuilderFieldToDbField = (
  fbField: FormField,
  index: number,
  parentId: string | null,
): any => {
  const dbField: any = {
    // id: fbField.id, // ID will be regenerated by the server action
    label: fbField.label,
    field_type: mapFormBuilderFieldTypeToDbFieldType(fbField.type),
    is_required: fbField.required,
    placeholder: fbField.placeholder || null,
    order: index,
    parent_list_field_id: parentId,
  };

  if (fbField.options && fbField.options.length > 0) {
    dbField.options = fbField.options.map((opt) => ({
      label: opt,
      value: opt,
    }));
  }

  // If it's a table field, its columns will be processed separately by the server action's recursion
  // We don't need to include them here directly, as the server action handles the flat list with parent_list_field_id

  return dbField;
};

export function FormBuilder({ initialTemplate }: FormBuilderWrapperProps) {
  const [fields, setFields] = useState<FormField[]>([]);
  const [isPending, startTransition] = useTransition();

  useEffect(() => {
    if (initialTemplate?.fields) {
      // Filter top-level fields (those without a parent_list_field_id)
      const topLevelDbFields = initialTemplate.fields.filter(
        (f) => !f.parent_list_field_id,
      );
      const mappedFields: FormField[] = topLevelDbFields
        .sort((a, b) => a.order - b.order)
        .map((dbField) =>
          mapDbFieldToFormBuilderField(dbField, initialTemplate.fields),
        );
      setFields(mappedFields);
    }
  }, [initialTemplate]);

  const handleSave = () => {
    startTransition(async () => {
      const allFieldsToSave: any[] = [];

      // Flatten the FormBuilder's fields structure into a list for the server action
      const flattenFields = (
        fbFieldList: FormField[],
        parentId: string | null,
      ) => {
        fbFieldList.forEach((fbField, index) => {
          allFieldsToSave.push(
            mapFormBuilderFieldToDbField(fbField, index, parentId),
          );
          if (
            fbField.type === "table" &&
            fbField.columns &&
            fbField.columns.length > 0
          ) {
            flattenFields(fbField.columns, fbField.id); // Pass the FormBuilder's ID as parentId for nested columns
          }
        });
      };

      flattenFields(fields, null);

      const result = await updateTemplateFields(
        initialTemplate.id,
        allFieldsToSave,
      );
      if (result?.error) {
        toast.error("Failed to save template:", { description: result.error });
      } else {
        toast.success("Template saved successfully!");
      }
    });
  };

  return (
    <div className="flex h-full flex-col gap-4">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold tracking-tight">
            Edit Template: {initialTemplate.name}
          </h1>
          <p className="text-muted-foreground">{initialTemplate.description}</p>
        </div>
        <Button onClick={handleSave} disabled={isPending}>
          {isPending ? "Saving..." : "Save Template"}
        </Button>
      </div>
      <ExistingFormBuilder fields={fields} setFields={setFields} />
    </div>
  );
}
